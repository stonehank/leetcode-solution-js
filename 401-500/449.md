### 449. 序列化和反序列化二叉搜索树

难度：Middle

相关话题：`树`

序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。



设计一个算法来序列化和反序列化 **二叉搜索树** 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。



 **编码的字符串应尽可能紧凑。** 



 **注意** ：不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。




```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
  let res=''
  let arr=[root]
  while(arr.length&gt;0){
    let len=arr.length
    for(let i=0;i&lt;len;i++){
      let node=arr.shift()
      if(node){
        if(res==='')res+=node.val
        else res+=','+node.val
        arr.push(node.left)
        arr.push(node.right)
      }
    }
  }
  return res
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
  if(!data)return null
  let arr=data.split(',')
  let root=new TreeNode(+arr[0])
  for(let i=1;i&lt;arr.length;i++){
    let n=+arr[i]
    root=insert(root,n)
  }
  return root
  function insert(root,n){
    if(!root)return new TreeNode(n)
    if(root.val&lt;=n){
      root.right=insert(root.right,n)
    }else{
      root.left=insert(root.left,n)
    }
    return root
  }
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */



```
