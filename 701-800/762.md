### 762. 二进制表示中质数个计算置位

难度：Easy

相关话题：`位运算`

给定两个整数 `L` 和 `R` ，找到闭区间 `[L, R]` 范围内，计算置位位数为质数的整数个数。



（注意，计算置位代表二进制表示中1的个数。例如 `21` 的二进制表示 `10101` 有 3 个计算置位。还有，1 不是质数。）



**示例 1:** 



```

输入: L = 6, R = 10
输出: 4
解释:
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)
```


**示例 2:** 



```

输入: L = 10, R = 15
输出: 5
解释:
10 -> 1010 (2 个计算置位, 2 是质数)
11 -> 1011 (3 个计算置位, 3 是质数)
12 -> 1100 (2 个计算置位, 2 是质数)
13 -> 1101 (3 个计算置位, 3 是质数)
14 -> 1110 (3 个计算置位, 3 是质数)
15 -> 1111 (4 个计算置位, 4 不是质数)
```


**注意:** 




1.  `L, R` 是 `L <= R` 且在 `[1, 10^6]` 中的整数。

2.  `R - L` 的最大值为 10000。






-----

思路：

首先定义一个`primes`保存`20`以内的质数(因为最大的数字不超过20位)，接着对每一个数字`i`，求出`1`的数量，然后检查是否质数。

一个优化点是通过`n & (n-1)`，计算出一个数`n`的二进制中`1`的数量。

通过`n&(n-1)`，每次可以减少这个数二进制中最右边的`1`。

```
/**
 * @param {number} L
 * @param {number} R
 * @return {number}
 */
var countPrimeSetBits = function(L, R) {
  let primes = new Set([2,3,5,7,11,13,17,19]);
  let cache={},res=0;
  for(let i=L;i<=R;i++){
    let bc=0,tmp=i;
    while(tmp) {
      bc++;
      tmp = tmp &amp; (tmp - 1);
    }
    if(primes.has(bc))res++
  }
  return res
};
```

