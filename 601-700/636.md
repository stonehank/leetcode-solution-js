### 636. 函数的独占时间

难度：Middle

相关话题：`栈`

给出一个非抢占单线程CPU的 **n** 个函数运行日志，找到函数的独占时间。



每个函数都有一个唯一的 Id，从 **0**  到**n-1** ，函数可能会递归调用或者被其他函数调用。



日志是具有以下格式的字符串： `function_id：start_or_end：timestamp` 。例如： `"0:start:0"` 表示函数 0 从 0 时刻开始运行。 `"0:end:0"` 表示函数 0 在 0 时刻结束。



函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。你需要根据函数的 Id 有序地返回每个函数的独占时间。



**示例 1:** 



```
输入:
n = 2
logs = 
["0:start:0",
 "1:start:2",
 "1:end:5",
 "0:end:6"]
输出:[3, 4]
说明：
函数 0 在时刻 0 开始，在执行了  2个时间单位结束于时刻 1。
现在函数 0 调用函数 1，函数 1 在时刻 2 开始，执行 4 个时间单位后结束于时刻 5。
函数 0 再次在时刻 6 开始执行，并在时刻 6 结束运行，从而执行了 1 个时间单位。
所以函数 0 总共的执行了 2 +1 =3 个时间单位，函数 1 总共执行了 4 个时间单位。
```


**说明：** 




1. 输入的日志会根据时间戳排序，而不是根据日志Id排序。

2. 你的输出会根据函数Id排序，也就意味着你的输出数组中序号为 0 的元素相当于函数 0 的执行时间。

3. 两个函数不会在同时开始或结束。

4. 函数允许被递归调用，直到运行结束。

5. 1 <= n <= 100






-----

思路：

对每一段日志，分解成`id:state:time`三个变量。

定义一个变量`curTime`来跟踪当前的时间戳。

`stack`保存的是当前正在进行的任务，

如果遇到`start`，说明需要添加一个新的任务，`stack.push(id)`；

如果遇到`end`，说明完成了一个任务，`stack.pop()`；

注意的是，在`start`状态下，因为是当前时间`time`的起点开始的，因此计算上一个任务的执行时间要`curTime-time-1`；

在`end`状态下，是结束到当前时间`time`的重点，因此计算上一个任务执行时间要`curTime-time+1`。

```
/**
 * @param {number} n
 * @param {string[]} logs
 * @return {number[]}
 */
var exclusiveTime = function(n, logs) {
  let res=Array(n).fill(0)
  let curTime=0
  let stack=[]
  for(let i=0;i<logs.length;i++){
    let [id,state,time]=logs[i].split(":")
    if(state==="start"){
      if(stack.length>0)res[stack[stack.length-1]]+=time-curTime-1
      stack.push(id)
    }else{
      res[stack.pop()]+=time-curTime+1
    }
    curTime=time
  }
  return res
};
```

