### 600. 不含连续1的非负整数

难度：Hard

相关话题：`动态规划`

给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 **连续的1** 的个数。



 **示例 1:** 





```
输入:

 5
输出:

 5
解释:

 
下面是带有相应二进制表示的非负整数&lt;= 5：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。
```

 **说明:**  1 &lt;= n &lt;= 109




-----

思路：

这道题首先要计算出前32位的斐波那契数，原因如下：

当二进制k为`1-4位`的解如下：
```
             / 1000
         100      
       /     \ 1001      
  / 10          
1      \     / 1010
  \      101
    11(X)    \ 1011(X)
```
只有当尾数是`0`的下一轮能增加2个，尾数是`1`的下一轮只能增加1个，这是一个斐波那契数列，`f(k)=f(k-1)+f(k+1)`

当参数为`2^k`时，结果就是`f[k]+1`
 
当斐波那契数列(f)求出后，假设给定的参数`num`的而二进制为`10010110101`
 
当`k`为10，`1<<k`为 `10000000000`
两者按位且不为0，因此需要 `+f[10]`
 
> 这里`+f[k]`可以看成将`k`位的1变为0，在后`k-1`位中存在的非连续1的数量，
> 例如`f[10]`，可以看成9位的非连续1的数量

接着，要处理 `10110101`这一段,继续遍历k

当k为7，`1<<k`为  `10000000`，两者按位且不为0， `+f[7]`

接着处理`110101`

当k为5，`1<<k`为 `100000`，两者按位且不为0，`+f[5]`

但注意，继续遍历当k为4时，按位且同样不为0，说明存在2个1连续，

例如，`110101`，但出现2个1连续，则后面的不需要继续计算了，因为存在11开头，后面一定都不合法。



```
/**
 * @param {number} num
 * @return {number}
 */
var findIntegers = function(num) {
  let f=[];
  f[0] = 1;
  f[1] = 2;
  for (let i = 2; i &lt; 32; ++i)
    f[i] = f[i-1]+f[i-2];
  let ans = 0, k = 30, pre_bit = 0;
  while (k &gt;= 0) {
    /*
    例如num二进制为 10010110101
    当k为10，1&lt;&lt;k为 10000000000
    两者按位且不为0，因此需要 ``+f[10]``，
    &gt; 这里`+f[k]`可以看成将`k`位的1变为0，在后`k-1`位中存在的非连续1的数量，
    &gt; 例如`f[10]`，可以看成9位的非连续1的数量
    接着，要处理    `10110101`这一段,继续遍历k
    当k为7，`1&lt;&lt;k`为  `10000000`，两者按位且不为0， `+f[7]`
    接着处理       `110101`
    当k为5，`1&lt;&lt;k`为 `100000`，两者按位且不为0，`+f[5]`
    但注意，继续遍历当k为4时，按位且同样不为0，说明存在2个1连续，
    例如，110101，但出现2个1连续，则后面的不需要继续计算了，因为存在11开头，后面一定都不合法。
    */
    if (num&amp;(1&lt;&lt;k)) {
      ans += f[k];
      if (pre_bit) return ans;
      pre_bit = 1;
    }
    else
      pre_bit = 0;
    --k;
  }
  return ans+1;
};



```
