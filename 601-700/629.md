### 629. K个逆序对数组

难度：Hard

相关话题：`动态规划`

给出两个整数 `n` 和 `k` ，找出所有包含从 `1` 到 `n` 的数字，且恰好拥有 `k` 个逆序对的不同的数组的个数。



逆序对的定义如下：对于数组的第 `i` 个和第 `j` 个元素，如果满 `i` &lt; `j` 且 `a[i]` &gt; `a[j]` ，则其为一个逆序对；否则不是。



由于答案可能很大，只需要返回 答案 mod 109+ 7 的值。



 **示例 1:** 





```

输入:

 n = 3, k = 0
输出:

 1
解释:

 
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。

```

 **示例 2:** 





```

输入:

 n = 3, k = 1
输出:

 2
解释:

 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。

```

 **说明:** 





1.  `n` 的范围是 [1, 1000] 并且  `k`  的范围是 [0, 1000]。






-----

思路：

考虑一个例子，当我们知道`n=6`和`k=(0~3)`时的值为`dp[6][0]`,`dp[6][1]`,`dp[6][2]`,`dp[6][3]`

那么如果`n=7`,`k=3`，应该如何转换？

如果`7`放在第一位，则为`7(x*6)`，那么会增加6个逆序。

如果`7`放在第二位，则为`(x)7(x*5)`，那么会增加5个逆序。

...

因此，在这里，我们能够有效转换有(不需要管具体插入哪个位置，反正插入的那个位置能达到增加逆序的要求数量)

`dp[6][0]+插入7增加3个逆序`

`dp[6][1]+插入7增加2个逆序`

`dp[6][2]+插入7增加1个逆序`

`dp[6][3]+插入7增加0个逆序`

我们的转换为：

`dp[7][3] = dp[6][0]+dp[6][1]+dp[6][2]+dp[6][3]`

这种写法的时间复杂度是`O(n^2*k)`，最坏情况`n`,`k`都是1000，会TLE。

因此，需要优化一下，我们以`dp[i][j]`表示 `n==i`和`k==0~j`时的总和。

状态转移方程为：

`dp[i][j]=dp[i][j-1] + dp[i-1][j] - (j>=i ? dp[i-1][j-i] : 0)`

其中` (j>=i ? dp[i-1][j-i] : 0)`表示当超出极限时，需要减去之前的和

例如`n=7`的极限就是增加逆序数为6个，可以是`0~6`或者`1~7`等等。


```
/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var kInversePairs = function(n, k) {

  let dp=Array(n+1).fill().map(()=&gt;Array(k+1).fill(0))
  for(let i=1;i&lt;n+1;i++){
    dp[i][0]=1
  }
  let MOD=1e9+7
  for(let i=1;i&lt;n+1;i++){
    for(let j=1;j&lt;k+1;j++){
      let val=(dp[i-1][j]-(j&gt;=i ? dp[i-1][j-i] : 0) + MOD) % MOD
      dp[i][j]=(dp[i][j-1]+val) % MOD
      
    }
  }
  return (dp[n][k]-(dp[n][k-1] || 0)+MOD) % MOD
};



```
