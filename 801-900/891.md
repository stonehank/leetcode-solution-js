### 891. 子序列宽度之和

难度：Hard

相关话题：`数组`、`数学`

给定一个整数数组  `A`  ，考虑  `A`  的所有非空子序列。



对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。



返回 A 的所有子序列的宽度之和。



由于答案可能非常大，请**返回答案模 10^9+7** 。







**示例：** 



```
输入：[2,1,3]
输出：6
解释：子序列为 [1]，[2]，[3]，[2,1]，[2,3]，[1,3]，[2,1,3] 。
相应的宽度是 0，0，0，1，1，2，2 。
这些宽度之和是 6 。
```






**提示：** 




* `1 <= A.length <= 20000`

* `1 <= A[i] <= 20000`






-----

思路：

因为这里只是要求子序列内部的最大最小值，因此子序列的顺序是没有影响的，可以先执行排序。

最初的想法是，对每一项`A[i]`，找出当它作为最小值时，能贡献的宽度和，但这么做内部也要遍历一遍剩下的数。
最终时间复杂度是`O(N^2)`，不符合要求。

其实对于每一项`A[i]`，我们不需要再去遍历它之后的数字。

因为这个数组已经排好序，这个数`A[i]`后面的所有数组成的序列，一定存在`2^len-i-1`个子序列以`A[i]`为最小值；

同样，这个数`A[i]`前面的所有数组成的序列，也一定存在`2^i`个子序列以`A[i]`为最大值；

找出它作为最小值时的序列数，和它作为最大值的序列数，这两个数分别乘上`A[i]`，也就是`A[i]`能贡献的作为最大值和最小值的总和。

因此`res+=A[i]* (2^i) - A[i]*(2^(len-i-1))`

但还有一个要注意，我们不能直接使用`Math.pow`，因为长度和`A[i]`最多有`20000`，`Math.pow(20000,20000)`是会溢出的。

因此需要2个数组保存`pow`，见代码。

```
/**
 * @param {number[]} A
 * @return {number}
 */
var sumSubseqWidths = function(A) {
  let MOD=1e9+7
  A.sort((a,b)=>a-b)
  let leftPow=Array(A.length).fill(1),
      rightPow=Array(A.length).fill(1)
  for(let i=1;i<A.length;i++){
    leftPow[i]=(leftPow[i-1]*2)%MOD
  }
  for(let i=A.length-2;i>=0;i--){
    rightPow[i]=(rightPow[i+1]*2)%MOD
  }
  let res=0
  for(let i=0,p=1;i<A.length;i++,p=(p<<1) % MOD){
    res=(res + A[i]*leftPow[i]-A[i]*rightPow[i]) % MOD
  }
  return res
};
```

