### 926. 将字符串翻转到单调递增

难度：Middle

相关话题：`数组`

如果一个由 `'0'`  和  `'1'` 组成的字符串，是以一些  `'0'` （可能没有  `'0'` ）后面跟着一些  `'1'` （也可能没有  `'1'` ）的形式组成的，那么该字符串是*单调递增* 的。



我们给出一个由字符  `'0'`  和  `'1'` 组成的字符串 `S` ，我们可以将任何 `'0'`  翻转为 `'1'` 或者将 `'1'` 翻转为 `'0'` 。



返回使  `S`  单调递增的最小翻转次数。







**示例 1：** 



```
输入："00110"
输出：1
解释：我们翻转最后一位得到 00111.
```


**示例 2：** 



```
输入："010110"
输出：2
解释：我们翻转得到 011111，或者是 000111。
```


**示例 3：** 



```
输入："00011000"
输出：2
解释：我们翻转得到 00000000。
```






**提示：** 




1.  `1 <= S.length <= 20000` 

2.  `S`  中只包含字符 `'0'` 和 `'1'` 






-----

思路：

这道题要求3种格式，分别是`00`,`01`,`11`

因此，数字`0`前面必须是`0`，数字`1`前面可以是`0`或者`1`。

我们定义2个数组`beZero`和`beOne`，分别用来保存如果当前值要反转成`0`或者`1`需要的次数。

通过上面分析，可以得到以下公式：

```
if S[i]=="0":
beZero[i]=beZero[i-1]
beOne[i]=Math.min(beZero[i-1],beOne[i-1]) + 1

if S[i]=="1":
beZero[i]=beZero[i-1] + 1
beOne[i]=Math.min(beZero[i-1],beOne[i-1])
```

```
/**
 * @param {string} S
 * @return {number}
 */
var minFlipsMonoIncr = function(S) {
    let s0=0,s1=0,prev_s0,prev_s1
    for(let i=0;i<S.length;i++){
        prev_s0=s0;prev_s1=s1
        s0=prev_s0+(S[i]==="0"?0:1)
        s1=Math.min(prev_s0,prev_s1)+(S[i]==="1"?0:1)
    }
    return Math.min(s0,s1)
};
```

